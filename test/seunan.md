## table of contents

- [table of contents](#table-of-contents)
- [Todo](#todo)
- [Analyzing a subject](#analyzing-a-subject)
- [Mandatory](#mandatory)
- [Bonus part](#bonus-part)

## Todo

- [ ] parsing
	- [ ] [parsing 순서](https://mywiki.wooledge.org/BashParser)
	- [ ] parsing 자료구조 트리? 리스트?
- [ ] execute
	- [ ] 다중 파이프
	- [ ] 환경 변수 변환?
	- [ ] awk 문법(파싱할 때 변수가 제일 많음)
- [ ] 환경 변수 출력하기

## Analyzing a subject

- [ref](https://www.geeksforgeeks.org/developing-linux-based-shell/)
- [ref](https://vorpaljs.github.io/bash-parser-playground/)

```bash
# success
bash-3.2$ 'l''''''''s'
bash-3.2$ 'ls'
bash-3.2$ "l""""""""s"
bash-3.2$ "ls"
bash-3.2$ ls;
bash-3.2$ ""gre"p" "a" # 따옴표에 묶인 상태에서 공백 구분자를 만났을 때 따옴표의 짝이 맞은 상태라서 ""gre"p" 과 "a" 두 개의 토큰
bash-3.2$ 'l''''''s'|grep"" "a"
bash-3.2$ 'ls'|"grep" "a"

# failure
bash-3.2$ 'ls
'
bash-3.2$ "gr"ep" a" # 따옴표에 묶인 상태에서 공백 구분자를 만났을 때 따옴표의 짝이 안맞은 상태라서 "gr"ep" a"이 하나의 토큰
bash-3.2$ "ls -a"
```



`>>, << 고려하기`

1. ' ', '|', '\0' 기준 토큰화
	1. 따옴표 짝이 맞아있는 상태일 때만
2. 따옴표로 묶여 있는 문자열 안의 따옴표 트림
3. 연결 리스트에 넣기
## Mandatory

- 당신의 쉘은:
	- 새로운 명령어를 입력할 수 있는 `프롬프트`를 보여줘야 합니다 -> readline
	- 작업 `히스토리`를 갖고 있어야 합니다. -> add_history
	- (PATH 변수나 상대, 절대 경로를 활용하여) 올바른 실행 파일을 찾아 실행할 수 있어야 합니다. -> parse, exceve
	- `전역변수`는 한 개 초과를 사용할 수 없으며, 왜 전역변수를 사용했는지 깊게 생각해 보고 그 이유를 설명할 수 있어야 합니다. -> shell 종료 시?
	- 닫히지 않은 따옴표나 특정되지 않은 특수문자 (\\나 ; 등...) 을 해석하지 않아야 합니다.
	- ' (단일 따옴표) 안에 있는 메타문자를 해석하지 않아야 합니다.
	- " (이중 따옴표) 안에 있는 $ (달러 기호)를 제외한 메타문자를 해석하지 않아야 합니다.
- 다음의 리다이렉션을 구현해야 합니다:
	- `<`는 입력을 리다이렉션 하여야 합니다
	- `>`는 출력을 리다이렉션 하여야 합니다
	- `<<`에 구분 기호를 지정한 다음, 현재 소스에서 구분자를 포함한 줄을 만나기 전까지 입력값을 읽어들입니다. 기록을 업데이트할 필요는 없습니다!
	- `>>`는 출력을 추가 모드로 리다이렉션합니다. -> open(append)
- `파이프`( `|` 문자)를 구현해야 합니다. 각 파이프라인마다 명령어의 출력값은 파이프로 연결되어 다음 명령어의 입력값으로 들어가야 합니다. -> pipex
- `환경변수` (`$` 다음에 문자열이 오는 형식) 은 그들의 값으로 확장되어야 합니다.
- `$?`는 가장 최근에 실행한 포그라운드 파이프라인의 종료 상태를 확장하여야 합니다
- `ctrl-C`, `ctrl-D` 그리고 `ctrl-\` 는 bash와 동일하게 동작하여야 합니다.
- 상호작용이 가능할 때:
	- `ctrl-C`는 새로운 줄에 새로운 프롬프트를 출력합니다
	- `ctrl-D`는 쉘을 종료합니다.
	- `ctrl-\`은 아무런 동작도 하지 않습니다.
- 다음의 `내장 기능들`을 실행할 수 있어야 합니다:
	- `-n` 옵션을 사용할 수 있는 `echo`
	- 오직 상대 또는 절대경로만 사용하는 `cd` -> chdir
	- 옵션이 없는 `pwd`
	- 옵션이 없는 `export`
	- 옵션이 없는 `unset`
	- 옵션이나 인자값이 없는 `env`
	- 옵션이 없는 `exit`
- `readline()` 함수는 메모리 누수를 일으킬 수 있습니다. 이를 고칠 필요는 없습니다. 하지만 `당신이 직접 작성한 코드는 메모리 누수를 일으킬 수 있다는 것을 의미합니다.`

> 💡 여러분은 과제의 설명에만 국한되도록 설계해야 합니다. 요구하지 않은 것들을 만드실 필요는 없습니다.<br>의문점이 생긴다면 [bash](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/)를 참고하세요.

## Bonus part

<br>

- 여러분의 프로그램은 다음을 구현해야 합니다:
	- 괄호를 이용해 우선순위를 표현한 `&&, ||`
	- 와일드카드 `*`가 현재 작업 디렉토리에 대해 동작하여야 합니다.

> 보너스는 필수로 구현해야 하는 파트가 완벽할 때만 평가될 것입니다. '완벽함' 이란, 모든 필수 파트가 전부 구현되어 있어야 하며 오작동하는 부분이 없어야 함을 의미합니다. 필수로 구현해야 하는 파트에서 만점을 받지 못한다면, 보너스 항목은 채점되지 않습니다.

